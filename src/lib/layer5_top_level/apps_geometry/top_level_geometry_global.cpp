/*
 * top_level_geometry_global.cpp
 *
 *  Created on: May 23, 2021
 *      Author: betten
 */


#include "orbiter.h"

using namespace std;


namespace orbiter {
namespace layer5_applications {
namespace apps_geometry {


top_level_geometry_global::top_level_geometry_global()
{
	Record_birth();

}

top_level_geometry_global::~top_level_geometry_global()
{
	Record_death();


}


void top_level_geometry_global::set_stabilizer_projective_space(
		projective_geometry::projective_space_with_action *PA,
		int intermediate_subset_size,
		std::string &fname_mask, int nb, std::string &column_label,
		std::string &fname_out,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);


	if (f_v) {
		cout << "top_level_geometry_global::set_stabilizer_projective_space" << endl;
	}

	set_stabilizer::substructure_classifier *SubC;

	SubC = NEW_OBJECT(set_stabilizer::substructure_classifier);

	SubC->set_stabilizer_in_any_space(
			PA->A, PA->A, PA->A->Strong_gens,
			intermediate_subset_size,
			fname_mask, nb, column_label,
			fname_out,
			verbose_level);


	FREE_OBJECT(SubC);
	if (f_v) {
		cout << "top_level_geometry_global::set_stabilizer_projective_space done" << endl;
	}

}


void top_level_geometry_global::report_decomposition_by_group(
		projective_geometry::projective_space_with_action *PA,
		groups::strong_generators *SG, std::ostream &ost, std::string &fname_base,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_group" << endl;
	}

	//long int order;


	//order = SG->group_order_as_lint();


#if 0
	ost << "The group generated by the element" << endl;
	ost << "$$" << endl;
	A->element_print_latex(Elt, ost);
	ost << "$$" << endl;
	ost << "has the following orbits:\\\\" << endl;

	ost << "Orbits on points:\\\\" << endl;
#endif

	groups::schreier *Sch1;
	groups::schreier *Sch2;

	Sch1 = NEW_OBJECT(groups::schreier);
	actions::action_global AcGl;

	AcGl.all_point_orbits_from_generators(PA->A,
			*Sch1,
			SG,
			0 /* verbose_level */);


	//ost << "Orbits on lines:\\\\" << endl;

	Sch2 = NEW_OBJECT(groups::schreier);
	AcGl.all_point_orbits_from_generators(PA->A_on_lines,
			*Sch2,
			SG,
			0 /* verbose_level */);
	//Sch->print_orbit_lengths_tex(ost);




	ost << "Considering the group generated by" << endl;
	SG->print_generators_tex(ost);

	if (Sch1->nb_orbits == 1 && Sch2->nb_orbits == 1) {
		ost << "The group is transitive on points and on lines.\\\\" << endl;
		std::vector<int> Orb1;
		std::vector<int> Orb2;
		Sch1->get_orbit_in_order(Orb1, 0 /* orbit_idx */, verbose_level);
		Sch2->get_orbit_in_order(Orb2, 0 /* orbit_idx */, verbose_level);

		int *Inc;
		other::orbiter_kernel_system::file_io Fio;
		string fname;

		fname = fname_base + "_incma_transitive.csv";

		PA->P->Subspaces->make_incidence_matrix(Orb1, Orb2, Inc, verbose_level);

		Fio.Csv_file_support->int_matrix_write_csv(
				fname, Inc, Orb1.size(), Orb2.size());

		FREE_int(Inc);

	}



	ost << "Orbits on points:\\\\" << endl;
	Sch1->print_orbit_lengths_tex(ost);

	ost << "Orbits on lines:\\\\" << endl;
	Sch2->print_orbit_lengths_tex(ost);

	ost << "Fixed points:\\\\" << endl;
	Sch1->print_fixed_points_tex(ost);

	ost << "Fixed lines:\\\\" << endl;
	Sch2->print_fixed_points_tex(ost);


	if (PA->f_has_action_on_planes) {
		groups::schreier *Sch3;
		Sch3 = NEW_OBJECT(groups::schreier);
		actions::action_global AcGl;
		AcGl.all_point_orbits_from_generators(PA->A_on_planes,
				*Sch3,
				SG,
				0 /*verbose_level*/);
		ost << "Fixed planes:\\\\" << endl;
		Sch3->print_fixed_points_tex(ost);

		FREE_OBJECT(Sch3);
	}




	{
		geometry::other_geometry::incidence_structure *Inc;
		other::data_structures::partitionstack *Stack;

		combinatorics_with_groups::combinatorics_with_action CombiA;

		if (f_v) {
			cout << "top_level_geometry_global::report_decomposition_by_group "
					"before CombiA.compute_decomposition_based_on_orbit_length" << endl;
		}
		CombiA.compute_decomposition_based_on_orbit_length(PA->P,
					Sch1, Sch2,
					Inc, Stack, 0 /*verbose_level*/);
		if (f_v) {
			cout << "top_level_geometry_global::report_decomposition_by_group "
					"after CombiA.compute_decomposition_based_on_orbit_length" << endl;
		}



		combinatorics::tactical_decompositions::decomposition *Decomposition;


		Decomposition = NEW_OBJECT(combinatorics::tactical_decompositions::decomposition);

		Decomposition->init_inc_and_stack(
				Inc, Stack,
				verbose_level);




		while (true) {

			int ht0, ht1;

			ht0 = Stack->ht;

			if (f_v) {
				cout << "process_single_case "
						"before refine_column_partition_safe" << endl;
			}
			Decomposition->refine_column_partition_safe(verbose_level - 2);
			if (f_v) {
				cout << "process_single_case "
						"after refine_column_partition_safe" << endl;
			}
			if (f_v) {
				cout << "process_single_case "
						"before refine_row_partition_safe" << endl;
			}
			Decomposition->refine_row_partition_safe(verbose_level - 2);
			if (f_v) {
				cout << "process_single_case "
						"after refine_row_partition_safe" << endl;
			}
			ht1 = Stack->ht;
			if (ht1 == ht0) {
				break;
			}
		}

		int f_labeled = true;

		Decomposition->print_partitioned(cout, f_labeled);
		Decomposition->get_and_print_decomposition_schemes();
		Stack->print_classes(cout);


		int f_print_subscripts = false;
		ost << "Decomposition based on orbit lengths:\\\\" << endl;
		ost << "Row scheme:\\\\" << endl;
		Decomposition->get_and_print_row_tactical_decomposition_scheme_tex(
			ost, true /* f_enter_math */,
			f_print_subscripts);
		ost << "Column scheme:\\\\" << endl;
		Decomposition->get_and_print_column_tactical_decomposition_scheme_tex(
			ost, true /* f_enter_math */,
			f_print_subscripts);



		FREE_OBJECT(Decomposition);
		FREE_OBJECT(Inc);
		//FREE_OBJECT(Stack);
	}





	{
		geometry::other_geometry::incidence_structure *Inc;
		other::data_structures::partitionstack *Stack;

		combinatorics_with_groups::combinatorics_with_action CombiA;

		if (f_v) {
			cout << "top_level_geometry_global::report_decomposition_by_group "
					"before CombiA.compute_decomposition_based_on_orbits" << endl;
		}
		CombiA.compute_decomposition_based_on_orbits(PA->P,
					Sch1, Sch2,
					Inc, Stack, 0 /*verbose_level*/);
		if (f_v) {
			cout << "top_level_geometry_global::report_decomposition_by_group "
					"after CombiA.compute_decomposition_based_on_orbits" << endl;
		}


		combinatorics::tactical_decompositions::decomposition *Decomposition;


		Decomposition = NEW_OBJECT(combinatorics::tactical_decompositions::decomposition);

		Decomposition->init_inc_and_stack(
				Inc, Stack,
				verbose_level);


		int f_print_subscripts = false;
		ost << "Decomposition based on orbits:\\\\" << endl;
		ost << "Row scheme:\\\\" << endl;
		Decomposition->get_and_print_row_tactical_decomposition_scheme_tex(
			ost, true /* f_enter_math */,
			f_print_subscripts);
		ost << "Column scheme:\\\\" << endl;
		Decomposition->get_and_print_column_tactical_decomposition_scheme_tex(
			ost, true /* f_enter_math */,
			f_print_subscripts);



		FREE_OBJECT(Decomposition);
		FREE_OBJECT(Inc);
		//FREE_OBJECT(Stack);
	}



	FREE_OBJECT(Sch1);
	FREE_OBJECT(Sch2);


	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_group done" << endl;
	}

}

void top_level_geometry_global::report_decomposition_by_single_automorphism(
		projective_geometry::projective_space_with_action *PA,
		int *Elt, std::ostream &ost, std::string &fname_base,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism" << endl;
	}

#if 0
	if (P->n != 3) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism P->n != 3" << endl;
		exit(1);
	}
#endif
	//projective_space *P3;
	int order;

	algebra::ring_theory::longinteger_object full_group_order;
	order = PA->A->Group_element->element_order(Elt);

	full_group_order.create(order);

	//P3 = P;

	//ost << "Fixed Objects:\\\\" << endl;


#if 0
	ost << "The group generated by the element" << endl;
	ost << "$$" << endl;
	A->element_print_latex(Elt, ost);
	ost << "$$" << endl;
	ost << "has the following orbits:\\\\" << endl;

	ost << "Orbits on points:\\\\" << endl;
#endif

	groups::schreier *Sch1;
	groups::schreier *Sch2;
	geometry::other_geometry::incidence_structure *Inc;
	other::data_structures::partitionstack *Stack;
	other::data_structures::partitionstack S1;
	other::data_structures::partitionstack S2;

	Sch1 = NEW_OBJECT(groups::schreier);
	Sch2 = NEW_OBJECT(groups::schreier);
	actions::action_global AcGl;

	AcGl.all_point_orbits_from_single_generator(
			PA->A,
			*Sch1,
			Elt,
			0 /*verbose_level*/);

	//ost << "Orbits on lines:\\\\" << endl;

	Sch2 = NEW_OBJECT(groups::schreier);
	AcGl.all_point_orbits_from_single_generator(
			PA->A_on_lines,
			*Sch2,
			Elt,
			0 /*verbose_level*/);
	//Sch->print_orbit_lengths_tex(ost);


	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"before incidence_and_stack_for_type_ij" << endl;
	}
	PA->P->Subspaces->incidence_and_stack_for_type_ij(
		1 /* row_type */, 2 /* col_type */,
		Inc,
		Stack,
		0 /*verbose_level*/);
	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"after incidence_and_stack_for_type_ij" << endl;
	}

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"before S1.allocate" << endl;
	}
	S1.allocate(PA->A->degree, 0 /* verbose_level */);
	S2.allocate(PA->A_on_lines->degree, 0 /* verbose_level */);

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"before Sch1->get_orbit_partition" << endl;
	}
	Sch1->get_orbit_partition(S1, 0 /*verbose_level*/);
	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"before Sch2->get_orbit_partition" << endl;
	}
	Sch2->get_orbit_partition(S2, 0 /*verbose_level*/);
	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"after Sch2->get_orbit_partition" << endl;
	}
	int i, j, sz;

	for (i = 1; i < S1.ht; i++) {
		if (f_v) {
			cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
					"before Stack->split_cell (S1) i=" << i << endl;
		}
		Stack->split_cell(
				S1.pointList + S1.startCell[i],
				S1.cellSize[i], verbose_level);
	}
	int *set;
	set = NEW_int(PA->A_on_lines->degree);
	for (i = 1; i < S2.ht; i++) {
		sz = S2.cellSize[i];
		Int_vec_copy(S2.pointList + S2.startCell[i], set, sz);
		for (j = 0; j < sz; j++) {
			set[j] += PA->A->degree;
		}
		if (f_v) {
			cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
					"before Stack->split_cell (S2) i=" << i << endl;
		}
		Stack->split_cell(set, sz, 0 /*verbose_level*/);
	}
	FREE_int(set);


	ost << "Considering the cyclic group generated by" << endl;
	ost << "$$" << endl;
	PA->A->Group_element->element_print_latex(Elt, ost);
	ost << "$$" << endl;

	if (Sch1->nb_orbits == 1 && Sch2->nb_orbits == 1) {
		ost << "The group is transitive on points and on lines.\\\\" << endl;
		std::vector<int> Orb1;
		std::vector<int> Orb2;
		Sch1->get_orbit_in_order(Orb1, 0 /* orbit_idx */, verbose_level);
		Sch2->get_orbit_in_order(Orb2, 0 /* orbit_idx */, verbose_level);

		int *Inc;
		other::orbiter_kernel_system::file_io Fio;
		string fname;

		fname = fname_base + "_incma_cyclic.csv";

		PA->P->Subspaces->make_incidence_matrix(Orb1, Orb2, Inc, verbose_level);

		Fio.Csv_file_support->int_matrix_write_csv(
				fname, Inc, Orb1.size(), Orb2.size());

		FREE_int(Inc);

		int p;
		for (p = 2; p < Orb1.size(); p++) {

			if ((Orb1.size() % p) == 0) {

				cout << "considering subgroup of index " << p << endl;

				int *v, *w;
				std::vector<int> Orb1_subgroup;
				std::vector<int> Orb2_subgroup;
				combinatorics::other_combinatorics::combinatorics_domain Combi;

				v = NEW_int(Orb1.size());
				w = NEW_int(Orb1.size());
				for (i = 0; i < Orb1.size(); i++) {
					v[i] = Orb1[i];
				}
				Combi.int_vec_splice(v, w, Orb1.size(), p);
				for (i = 0; i < Orb1.size(); i++) {
					Orb1_subgroup.push_back(w[i]);

				}

				for (i = 0; i < Orb1.size(); i++) {
					v[i] = Orb2[i];
				}
				Combi.int_vec_splice(v, w, Orb1.size(), p);
				for (i = 0; i < Orb1.size(); i++) {
					Orb2_subgroup.push_back(w[i]);

				}
				FREE_int(v);
				FREE_int(w);

				fname = fname_base + "_incma_subgroup_index_" + std::to_string(p) + ".csv";

				PA->P->Subspaces->make_incidence_matrix(
						Orb1_subgroup, Orb2_subgroup, Inc, verbose_level);

				Fio.Csv_file_support->int_matrix_write_csv(
						fname, Inc, Orb1.size(), Orb2.size());
				FREE_int(Inc);
			}
		}

	}



	ost << "Orbits on points:\\\\" << endl;
	Sch1->print_orbit_lengths_tex(ost);

	ost << "Orbits on lines:\\\\" << endl;
	Sch2->print_orbit_lengths_tex(ost);

	ost << "Fixed points:\\\\" << endl;
	Sch1->print_fixed_points_tex(ost);

	ost << "Fixed lines:\\\\" << endl;
	Sch2->print_fixed_points_tex(ost);


	if (PA->f_has_action_on_planes) {
		groups::schreier *Sch3;
		actions::action_global AcGl;
		Sch3 = NEW_OBJECT(groups::schreier);
		AcGl.all_point_orbits_from_single_generator(PA->A_on_planes,
				*Sch3,
				Elt,
				0 /*verbose_level*/);
		ost << "Fixed planes:\\\\" << endl;
		Sch3->print_fixed_points_tex(ost);

		FREE_OBJECT(Sch3);
	}


	combinatorics::tactical_decompositions::decomposition *Decomposition;


	Decomposition = NEW_OBJECT(combinatorics::tactical_decompositions::decomposition);

	Decomposition->init_inc_and_stack(
			Inc, Stack,
			verbose_level);


	int f_print_subscripts = false;
	ost << "Row scheme:\\\\" << endl;
	Decomposition->get_and_print_row_tactical_decomposition_scheme_tex(
		ost, true /* f_enter_math */,
		f_print_subscripts);
	ost << "Column scheme:\\\\" << endl;
	Decomposition->get_and_print_column_tactical_decomposition_scheme_tex(
		ost, true /* f_enter_math */,
		f_print_subscripts);



	FREE_OBJECT(Sch1);
	FREE_OBJECT(Sch2);
	FREE_OBJECT(Inc);
	FREE_OBJECT(Decomposition);
	//FREE_OBJECT(Stack);

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism done" << endl;
	}
}


}}}



