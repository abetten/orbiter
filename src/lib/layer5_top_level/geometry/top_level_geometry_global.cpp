/*
 * top_level_geometry_global.cpp
 *
 *  Created on: May 23, 2021
 *      Author: betten
 */


#include "orbiter.h"

using namespace std;


namespace orbiter {
namespace layer5_applications {
namespace apps_geometry {


top_level_geometry_global::top_level_geometry_global()
{

}

top_level_geometry_global::~top_level_geometry_global()
{

}


void top_level_geometry_global::set_stabilizer_projective_space(
		projective_geometry::projective_space_with_action *PA,
		int intermediate_subset_size,
		std::string &fname_mask, int nb, std::string &column_label,
		std::string &fname_out,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);


	if (f_v) {
		cout << "top_level_geometry_global::set_stabilizer_projective_space" << endl;
	}

	set_stabilizer::substructure_classifier *SubC;

	SubC = NEW_OBJECT(set_stabilizer::substructure_classifier);

	SubC->set_stabilizer_in_any_space(
			PA->A, PA->A, PA->A->Strong_gens,
			intermediate_subset_size,
			fname_mask, nb, column_label,
			fname_out,
			verbose_level);


	FREE_OBJECT(SubC);
	if (f_v) {
		cout << "top_level_geometry_global::set_stabilizer_projective_space done" << endl;
	}

}


void top_level_geometry_global::report_decomposition_by_group(
		projective_geometry::projective_space_with_action *PA,
		groups::strong_generators *SG, std::ostream &ost, std::string &fname_base,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "projective_space_with_action::report_decomposition_by_group" << endl;
	}

	//long int order;


	//order = SG->group_order_as_lint();


#if 0
	ost << "The group generated by the element" << endl;
	ost << "$$" << endl;
	A->element_print_latex(Elt, ost);
	ost << "$$" << endl;
	ost << "has the following orbits:\\\\" << endl;

	ost << "Orbits on points:\\\\" << endl;
#endif

	groups::schreier *Sch1;
	groups::schreier *Sch2;

	Sch1 = NEW_OBJECT(groups::schreier);
	actions::action_global AcGl;

	AcGl.all_point_orbits_from_generators(PA->A,
			*Sch1,
			SG,
			0 /* verbose_level */);


	//ost << "Orbits on lines:\\\\" << endl;

	Sch2 = NEW_OBJECT(groups::schreier);
	AcGl.all_point_orbits_from_generators(PA->A_on_lines,
			*Sch2,
			SG,
			0 /* verbose_level */);
	//Sch->print_orbit_lengths_tex(ost);




	ost << "Considering the group generated by" << endl;
	SG->print_generators_tex(ost);

	if (Sch1->nb_orbits == 1 && Sch2->nb_orbits == 1) {
		ost << "The group is transitive on points and on lines.\\\\" << endl;
		std::vector<int> Orb1;
		std::vector<int> Orb2;
		Sch1->get_orbit_in_order(Orb1, 0 /* orbit_idx */, verbose_level);
		Sch2->get_orbit_in_order(Orb2, 0 /* orbit_idx */, verbose_level);

		int *Inc;
		orbiter_kernel_system::file_io Fio;
		string fname;

		fname.assign(fname_base);
		fname.append("_incma_transitive.csv");

		PA->P->Subspaces->make_incidence_matrix(Orb1, Orb2, Inc, verbose_level);

		Fio.int_matrix_write_csv(fname, Inc, Orb1.size(), Orb2.size());

		FREE_int(Inc);

	}



	ost << "Orbits on points:\\\\" << endl;
	Sch1->print_orbit_lengths_tex(ost);

	ost << "Orbits on lines:\\\\" << endl;
	Sch2->print_orbit_lengths_tex(ost);

	ost << "Fixed points:\\\\" << endl;
	Sch1->print_fixed_points_tex(ost);

	ost << "Fixed lines:\\\\" << endl;
	Sch2->print_fixed_points_tex(ost);


	if (PA->f_has_action_on_planes) {
		groups::schreier *Sch3;
		Sch3 = NEW_OBJECT(groups::schreier);
		actions::action_global AcGl;
		AcGl.all_point_orbits_from_generators(PA->A_on_planes,
				*Sch3,
				SG,
				0 /*verbose_level*/);
		ost << "Fixed planes:\\\\" << endl;
		Sch3->print_fixed_points_tex(ost);

		FREE_OBJECT(Sch3);
	}




	{
		geometry::incidence_structure *Inc;
		data_structures::partitionstack *Stack;

		actions::action_global AG;

		if (f_v) {
			cout << "projective_space_with_action::report_decomposition_by_group "
					"before AG.compute_decomposition_based_on_orbit_length" << endl;
		}
		AG.compute_decomposition_based_on_orbit_length(PA->P,
					Sch1, Sch2,
					Inc, Stack, 0 /*verbose_level*/);
		if (f_v) {
			cout << "projective_space_with_action::report_decomposition_by_group "
					"after AG.compute_decomposition_based_on_orbit_length" << endl;
		}



		while (TRUE) {

			int ht0, ht1;

			ht0 = Stack->ht;

			if (f_v) {
				cout << "process_single_case before refine_column_partition_safe" << endl;
			}
			Inc->refine_column_partition_safe(*Stack, verbose_level - 2);
			if (f_v) {
				cout << "process_single_case after refine_column_partition_safe" << endl;
			}
			if (f_v) {
				cout << "process_single_case before refine_row_partition_safe" << endl;
			}
			Inc->refine_row_partition_safe(*Stack, verbose_level - 2);
			if (f_v) {
				cout << "process_single_case after refine_row_partition_safe" << endl;
			}
			ht1 = Stack->ht;
			if (ht1 == ht0) {
				break;
			}
		}

		int f_labeled = TRUE;

		Inc->print_partitioned(cout, *Stack, f_labeled);
		Inc->get_and_print_decomposition_schemes(*Stack);
		Stack->print_classes(cout);


		int f_print_subscripts = FALSE;
		ost << "Decomposition based on orbit lengths:\\\\" << endl;
		ost << "Row scheme:\\\\" << endl;
		Inc->get_and_print_row_tactical_decomposition_scheme_tex(
			ost, TRUE /* f_enter_math */,
			f_print_subscripts, *Stack);
		ost << "Column scheme:\\\\" << endl;
		Inc->get_and_print_column_tactical_decomposition_scheme_tex(
			ost, TRUE /* f_enter_math */,
			f_print_subscripts, *Stack);



		FREE_OBJECT(Inc);
		FREE_OBJECT(Stack);
	}





	{
		geometry::incidence_structure *Inc;
		data_structures::partitionstack *Stack;

		actions::action_global AG;

		if (f_v) {
			cout << "projective_space_with_action::report_decomposition_by_group "
					"before AG.compute_decomposition_based_on_orbits" << endl;
		}
		AG.compute_decomposition_based_on_orbits(PA->P,
					Sch1, Sch2,
					Inc, Stack, 0 /*verbose_level*/);
		if (f_v) {
			cout << "projective_space_with_action::report_decomposition_by_group "
					"after AG.compute_decomposition_based_on_orbits" << endl;
		}


		int f_print_subscripts = FALSE;
		ost << "Decomposition based on orbits:\\\\" << endl;
		ost << "Row scheme:\\\\" << endl;
		Inc->get_and_print_row_tactical_decomposition_scheme_tex(
			ost, TRUE /* f_enter_math */,
			f_print_subscripts, *Stack);
		ost << "Column scheme:\\\\" << endl;
		Inc->get_and_print_column_tactical_decomposition_scheme_tex(
			ost, TRUE /* f_enter_math */,
			f_print_subscripts, *Stack);



		FREE_OBJECT(Inc);
		FREE_OBJECT(Stack);
	}



	FREE_OBJECT(Sch1);
	FREE_OBJECT(Sch2);


	if (f_v) {
		cout << "projective_space_with_action::report_decomposition_by_group done" << endl;
	}

}

void top_level_geometry_global::report_decomposition_by_single_automorphism(
		projective_geometry::projective_space_with_action *PA,
		int *Elt, std::ostream &ost, std::string &fname_base,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism" << endl;
	}

#if 0
	if (P->n != 3) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism P->n != 3" << endl;
		exit(1);
	}
#endif
	//projective_space *P3;
	int order;

	ring_theory::longinteger_object full_group_order;
	order = PA->A->Group_element->element_order(Elt);

	full_group_order.create(order, __FILE__, __LINE__);

	//P3 = P;

	//ost << "Fixed Objects:\\\\" << endl;


#if 0
	ost << "The group generated by the element" << endl;
	ost << "$$" << endl;
	A->element_print_latex(Elt, ost);
	ost << "$$" << endl;
	ost << "has the following orbits:\\\\" << endl;

	ost << "Orbits on points:\\\\" << endl;
#endif

	groups::schreier *Sch1;
	groups::schreier *Sch2;
	geometry::incidence_structure *Inc;
	data_structures::partitionstack *Stack;
	data_structures::partitionstack S1;
	data_structures::partitionstack S2;

	Sch1 = NEW_OBJECT(groups::schreier);
	Sch2 = NEW_OBJECT(groups::schreier);
	actions::action_global AcGl;

	AcGl.all_point_orbits_from_single_generator(PA->A,
			*Sch1,
			Elt,
			0 /*verbose_level*/);

	//ost << "Orbits on lines:\\\\" << endl;

	Sch2 = NEW_OBJECT(groups::schreier);
	AcGl.all_point_orbits_from_single_generator(PA->A_on_lines,
			*Sch2,
			Elt,
			0 /*verbose_level*/);
	//Sch->print_orbit_lengths_tex(ost);


	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"before incidence_and_stack_for_type_ij" << endl;
	}
	PA->P->Subspaces->incidence_and_stack_for_type_ij(
		1 /* row_type */, 2 /* col_type */,
		Inc,
		Stack,
		0 /*verbose_level*/);
	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"after incidence_and_stack_for_type_ij" << endl;
	}

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"before S1.allocate" << endl;
	}
	S1.allocate(PA->A->degree, 0 /* verbose_level */);
	S2.allocate(PA->A_on_lines->degree, 0 /* verbose_level */);

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"before Sch1->get_orbit_partition" << endl;
	}
	Sch1->get_orbit_partition(S1, 0 /*verbose_level*/);
	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"before Sch2->get_orbit_partition" << endl;
	}
	Sch2->get_orbit_partition(S2, 0 /*verbose_level*/);
	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
				"after Sch2->get_orbit_partition" << endl;
	}
	int i, j, sz;

	for (i = 1; i < S1.ht; i++) {
		if (f_v) {
			cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
					"before Stack->split_cell (S1) i=" << i << endl;
		}
		Stack->split_cell(
				S1.pointList + S1.startCell[i],
				S1.cellSize[i], verbose_level);
	}
	int *set;
	set = NEW_int(PA->A_on_lines->degree);
	for (i = 1; i < S2.ht; i++) {
		sz = S2.cellSize[i];
		Int_vec_copy(S2.pointList + S2.startCell[i], set, sz);
		for (j = 0; j < sz; j++) {
			set[j] += PA->A->degree;
		}
		if (f_v) {
			cout << "top_level_geometry_global::report_decomposition_by_single_automorphism "
					"before Stack->split_cell (S2) i=" << i << endl;
		}
		Stack->split_cell(set, sz, 0 /*verbose_level*/);
	}
	FREE_int(set);


	ost << "Considering the cyclic group generated by" << endl;
	ost << "$$" << endl;
	PA->A->Group_element->element_print_latex(Elt, ost);
	ost << "$$" << endl;

	if (Sch1->nb_orbits == 1 && Sch2->nb_orbits == 1) {
		ost << "The group is transitive on points and on lines.\\\\" << endl;
		std::vector<int> Orb1;
		std::vector<int> Orb2;
		Sch1->get_orbit_in_order(Orb1, 0 /* orbit_idx */, verbose_level);
		Sch2->get_orbit_in_order(Orb2, 0 /* orbit_idx */, verbose_level);

		int *Inc;
		orbiter_kernel_system::file_io Fio;
		string fname;

		fname.assign(fname_base);
		fname.append("_incma_cyclic.csv");

		PA->P->Subspaces->make_incidence_matrix(Orb1, Orb2, Inc, verbose_level);

		Fio.int_matrix_write_csv(fname, Inc, Orb1.size(), Orb2.size());

		FREE_int(Inc);

		int p;
		for (p = 2; p < Orb1.size(); p++) {

			if ((Orb1.size() % p) == 0) {

				cout << "considering subgroup of index " << p << endl;

				int *v, *w;
				std::vector<int> Orb1_subgroup;
				std::vector<int> Orb2_subgroup;
				combinatorics::combinatorics_domain Combi;

				v = NEW_int(Orb1.size());
				w = NEW_int(Orb1.size());
				for (i = 0; i < Orb1.size(); i++) {
					v[i] = Orb1[i];
				}
				Combi.int_vec_splice(v, w, Orb1.size(), p);
				for (i = 0; i < Orb1.size(); i++) {
					Orb1_subgroup.push_back(w[i]);

				}

				for (i = 0; i < Orb1.size(); i++) {
					v[i] = Orb2[i];
				}
				Combi.int_vec_splice(v, w, Orb1.size(), p);
				for (i = 0; i < Orb1.size(); i++) {
					Orb2_subgroup.push_back(w[i]);

				}
				FREE_int(v);
				FREE_int(w);

				fname.assign(fname_base);
				fname.append("_incma_subgroup");
				char str[1000];

				snprintf(str, sizeof(str), "_index_%d.csv", p);
				fname.append(str);

				PA->P->Subspaces->make_incidence_matrix(Orb1_subgroup, Orb2_subgroup, Inc, verbose_level);

				Fio.int_matrix_write_csv(fname, Inc, Orb1.size(), Orb2.size());
				FREE_int(Inc);
			}
		}

	}



	ost << "Orbits on points:\\\\" << endl;
	Sch1->print_orbit_lengths_tex(ost);

	ost << "Orbits on lines:\\\\" << endl;
	Sch2->print_orbit_lengths_tex(ost);

	ost << "Fixed points:\\\\" << endl;
	Sch1->print_fixed_points_tex(ost);

	ost << "Fixed lines:\\\\" << endl;
	Sch2->print_fixed_points_tex(ost);


	if (PA->f_has_action_on_planes) {
		groups::schreier *Sch3;
		actions::action_global AcGl;
		Sch3 = NEW_OBJECT(groups::schreier);
		AcGl.all_point_orbits_from_single_generator(PA->A_on_planes,
				*Sch3,
				Elt,
				0 /*verbose_level*/);
		ost << "Fixed planes:\\\\" << endl;
		Sch3->print_fixed_points_tex(ost);

		FREE_OBJECT(Sch3);
	}


	int f_print_subscripts = FALSE;
	ost << "Row scheme:\\\\" << endl;
	Inc->get_and_print_row_tactical_decomposition_scheme_tex(
		ost, TRUE /* f_enter_math */,
		f_print_subscripts, *Stack);
	ost << "Column scheme:\\\\" << endl;
	Inc->get_and_print_column_tactical_decomposition_scheme_tex(
		ost, TRUE /* f_enter_math */,
		f_print_subscripts, *Stack);



	FREE_OBJECT(Sch1);
	FREE_OBJECT(Sch2);
	FREE_OBJECT(Inc);
	FREE_OBJECT(Stack);

	if (f_v) {
		cout << "top_level_geometry_global::report_decomposition_by_single_automorphism done" << endl;
	}
}


}}}



