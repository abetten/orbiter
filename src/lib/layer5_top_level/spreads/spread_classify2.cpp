// spread_classify2.cpp
// 
// Anton Betten
// November 17, 2009
//
// 
//
// moved here from translation_plane.cpp: April 23, 2013
// moved to TOP_LEVEL: November 2, 2013
// renamed to spread2.cpp from translation_plane2.cpp: March 25, 2018
//
//

#include "orbiter.h"

using namespace std;

namespace orbiter {
namespace layer5_applications {
namespace spreads {




void spread_classify::print_isomorphism_type(
		isomorph::isomorph *Iso,
	int iso_cnt, groups::sims *Stab, groups::schreier &Orb,
	long int *data, int verbose_level)
// called from callback_print_isomorphism_type()
{
	int f_v = (verbose_level >= 1);
	string fname;
	string fname_klein;




	if (f_v) {
		cout << "spread_classify::print_isomorphism_type" << endl;
	}

	fname = Iso->prefix + "_" + std::to_string(iso_cnt) + ".tex";


	fname_klein = Iso->prefix + "_" + std::to_string(iso_cnt) + "_klein.tex";

	
	int save_longinteger_f_print_scientific = other::orbiter_kernel_system::Orbiter->longinteger_f_print_scientific;
	other::orbiter_kernel_system::Orbiter->longinteger_f_print_scientific = false;
	{
		ofstream file(fname);
		other::l1_interfaces::latex_interface L;

		string title, author, extra_praeamble;

		author.assign("Orbiter");

		//ofstream file_klein(fname_klein);
		if (f_v) {
			cout << "opening file " << fname << " for writing" << endl;
			//cout << "opening file " << fname_klein << " for writing" << endl;
		}
	
		L.head(file,
			false/* f_book*/, false /* f_title */,
			title /*title*/,
			author /*char *author*/, false/* f_toc*/,
			false /* f_landscape*/,
			false /* f_12pt */,
			true /* f_enlarged_page */,
			true /* f_pagenumbers */,
			extra_praeamble /* extra_praeamble */);


		print_isomorphism_type2(Iso, file, iso_cnt, Stab, Orb, data, verbose_level);
	
		L.foot(file);

		other::orbiter_kernel_system::Orbiter->longinteger_f_print_scientific = save_longinteger_f_print_scientific;
	}

	other::orbiter_kernel_system::file_io Fio;

	if (f_v) {
		cout << "spread_classify::print_isomorphism_type written file "
				<< fname << " of size " << Fio.file_size(fname) << endl;
		cout << "spread_classify::print_isomorphism_type written file "
				<< fname_klein << " of size "
				<< Fio.file_size(fname_klein) << endl;
	}



}


void spread_classify::print_isomorphism_type2(
		isomorph::isomorph *Iso,
		std::ostream &ost,
		int iso_cnt, groups::sims *Stab, groups::schreier &Orb,
		long int *data, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int i;
	algebra::ring_theory::longinteger_object so;
	long int *pt_list;
	int f, l, j, idx, pt;
	int p, h;
	int f_elements_exponential = false;
	string symbol_for_print;

	algebra::number_theory::number_theory_domain NT;
	other::data_structures::sorting Sorting;

	if (f_v) {
		cout << "spread_classify::print_isomorphism_type2" << endl;
	}


	symbol_for_print.assign("\\alpha");


	NT.factor_prime_power(SD->q, p, h);
	if (h > 1) {
		f_elements_exponential = true;
	}

	ost << "\\parindent=0pt" << endl;
	ost << endl;
	ost << "\\section{Spread " << iso_cnt << "}" << endl;
	//int_vec_print(file, data, q + 1);
	//file << endl;
	
	Stab->group_order(so);

	other::data_structures::tally C;


	C.init(Orb.Forest->orbit_len, Orb.Forest->nb_orbits, false, 0);

	ost << "Stabilizer has order " << so << "\\\\" << endl;
	
	ost << "\\bigskip" << endl;

	ost << "There are $" << Orb.Forest->nb_orbits
			<< "$ orbits on the set.\\\\" << endl;
	ost << "The orbit type is $[";
	C.print_bare_tex(ost, false /*f_backwards*/);
	ost << "]$\\\\" << endl;
	ost << "\\bigskip" << endl;
	

	if (SD->k == 2) {
		other::data_structures::tally *C;

		klein(
				//ost, /*file_klein,*/
				//Iso,
				iso_cnt,
				//Stab, Orb,
				data, Iso->size, C,
				verbose_level);

		ost << "Plane type of Klein-image is $( ";
		C->print_bare_tex(ost, false /*f_backwards*/);
		ost << " )$" << endl << endl;
		ost << "\\bigskip" << endl << endl;


		FREE_OBJECT(C);
	}

	ost << "The set of " << SD->k - 1 << "-Subspaces in "
			"PG($" << SD->n - 1 << ", " << SD->q << "$) is:\\\\" << endl;
	
	for (i = 0; i < Iso->size; i++) {
		ost << "$S_{" << i + 1 << "}$ has rank " << data[i]
			<< " and is generated by\\\\" << endl;
		SD->Grass->unrank_lint(data[i], 0);
		ost << "$$" << endl;
		ost << "\\left[" << endl;
		SD->F->Io->latex_matrix(
				ost, f_elements_exponential, symbol_for_print,
				SD->Grass->M, SD->k, SD->n);
		ost << "\\right]" << endl;
		ost << "$$" << endl << endl;
	}

	ost << "The stabilizer of order " << so
			<< " is generated by:\\\\" << endl;
	for (i = 0; i < Stab->gens.len; i++) {
		
		int n;
		
		//fp = NEW_int(A->degree);
		n = A->Group_element->count_fixed_points(
				Stab->gens.ith(i), 0);
		//cout << "with " << n << " fixed points" << endl;
		//FREE_int(fp);

		ost << "$$ g_{" << i + 1 << "}=" << endl;
		A->Group_element->element_print_latex(
				Stab->gens.ith(i), ost);
		ost << "$$" << endl << "with " << n << " fixed points" << endl;
	}



	if (f_v) {
		cout << "spread_classify::print_isomorphism_type "
				"before report_induced_action_on_set_and_kernel" << endl;
	}
	Iso->report_induced_action_on_set_and_kernel(
			ost,
			A, Stab, Iso->size, data, verbose_level - 1);

	if (f_v) {
		cout << "spread_classify::print_isomorphism_type "
				"after report_induced_action_on_set_and_kernel" << endl;
	}


#if 0
	for (i = 0; i < Stab->gens.len; i++) {
		file << "$g_{" << setw(2) << i + 1 << "} = ";
		AA->element_print_as_permutation_with_offset(Stab->gens.ith(i), file, 1);
		file << "$\\\\" << endl;
	}
#endif
	
	pt_list = NEW_lint(Iso->size);
	
	ost << "The orbits on the set are:\\\\" << endl;
	for (i = 0; i < Orb.Forest->nb_orbits; i++) {
		f = Orb.Forest->orbit_first[i];
		l = Orb.Forest->orbit_len[i];
		ost << "$O_{" << i << "}=\\{";
		for (j = 0; j < l; j++) {
			idx = f + j;
			pt = Orb.Forest->orbit[idx];
			pt_list[j] = pt;
		}
		
		Sorting.lint_vec_heapsort(pt_list, l);
		
		for (j = 0; j < l; j++) {		
			ost << pt_list[j] + 1;
			if (j < l - 1)
				ost << ",";
		}
		ost << "\\}$ (length $" << l << "$)\\\\" << endl;
	}

#if 0
	
	if (Orb.nb_orbits > 1) {
		file << "\\bigskip" << endl;
		file << "The actions induced on the orbits are:\\\\" << endl;
	
		for (i = 0; i < Orb.nb_orbits; i++) {
			induced_action_on_orbit(file, AA, Stab, Orb, i, verbose_level - 2);
		}
	}
#endif



	FREE_lint(pt_list);


	if (f_v) {
		cout << "spread_classify::print_isomorphism_type2 done" << endl;
	}

}

void spread_classify::save_klein_invariants(
		char *prefix,
	int iso_cnt, 
	long int *data, int data_size, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	algebra::ring_theory::longinteger_object *R;
	//long int **Pts_on_plane;
	//int *nb_pts_on_plane;
	//int nb_planes;
	other::data_structures::set_of_sets *Intersections;
	int i, j;

	if (f_v) {
		cout << "spread_classify::klein_invariants" << endl;
	}
	
	if (SD->Klein == NULL) {
		cout << "spread_classify::klein_invariants Klein == NULL" << endl;
		exit(1);
	}
	
	SD->Klein->plane_intersections(data, data_size,
		R,
		//Pts_on_plane,
		//nb_pts_on_plane,
		//nb_planes,
		Intersections,
		verbose_level - 2);


	typed_objects::Vector v;

	v.m_l(3);
	v.m_ii(0, Intersections->nb_sets);
	v.s_i(1).change_to_vector();
	v.s_i(2).change_to_vector();

	v.s_i(1).as_vector().m_l(Intersections->nb_sets);
	v.s_i(2).as_vector().m_l(Intersections->nb_sets);
	for (i = 0; i < Intersections->nb_sets; i++) {
		v.s_i(1).as_vector().m_ii(i, R[i].as_int());
		//v.s_i(1).as_vector().s_i(i).change_to_longinteger();
		//v.s_i(1).as_vector().s_i(i).as_longinteger().allocate(1, R[i].rep());
		v.s_i(2).as_vector().s_i(i).change_to_vector();
		v.s_i(2).as_vector().s_i(i).as_vector().m_l(Intersections->Set_size[i] /*nb_pts_on_plane[i]*/);
		for (j = 0; j < Intersections->Set_size[i]; j++) {
			v.s_i(2).as_vector().s_i(i).as_vector().m_ii(j, Intersections->Sets[i][j]);
		}
	}

	string fname;
	
	fname = prefix + std::to_string(iso_cnt) + "_klein_invariant.bin";
	v.save_file(fname);

	delete [] R;
#if 0
	for (i = 0; i < nb_planes; i++) {
		FREE_lint(Pts_on_plane[i]);
	}
	FREE_plint(Pts_on_plane);
	FREE_int(nb_pts_on_plane);
#endif
	FREE_OBJECT(Intersections);
	if (f_v) {
		cout << "spread_classify::klein_invariants done" << endl;
	}
}

void spread_classify::klein(
		//std::ostream &ost,
		//isomorph::isomorph *Iso,
	int iso_cnt, //groups::sims *Stab, groups::schreier &Orb,
	long int *data, int data_size,
	other::data_structures::tally *&C,
	int verbose_level)
// Called from print_isomorphism_type if k == 2
{
	int f_v = (verbose_level >= 1);
	algebra::ring_theory::longinteger_object *R;
	//long int **Pts_on_plane;
	//int *nb_pts_on_plane;
	//int nb_planes;

	other::data_structures::set_of_sets *Intersections;


	int set_size = data_size;
	int a, i, j, h;
	
	SD->Klein->plane_intersections(
			data, data_size,
			R,
			//Pts_on_plane,
			//nb_pts_on_plane,
			//nb_planes,
			Intersections,
			verbose_level);

	int f_second = false;

	C = NEW_OBJECT(other::data_structures::tally);

	//C->init(nb_pts_on_plane, nb_planes, f_second, 0);
	C->init_lint(Intersections->Set_size, Intersections->nb_sets, f_second, 0);
	if (f_v) {
		cout << "spread::klein: plane-intersection type: ";
		C->print(false /*f_backwards*/);
	}
	
	cout << "Plane type of Klein-image is $( ";
	C->print_bare_tex(cout, false /*f_backwards*/);
	cout << " )$" << endl << endl;
	cout << "\\bigskip" << endl << endl;

	int nb_blocks, f, l, m, u, uu, idx;
	int *Inc;
	
	m = 0;
	for (i = 0; i < C->nb_types; i++) {
		f = C->type_first[i];
		l = C->type_len[i];
		a = C->data_sorted[f];
		m = MAXIMUM(a, m);
	}

	nb_blocks = 0;
	for (i = 0; i < C->nb_types; i++) {
		f = C->type_first[i];
		l = C->type_len[i];
		a = C->data_sorted[f];
		if (a == m) {
			nb_blocks += l;
		}
	}
	if (f_v) {
		cout << "There are " << nb_blocks
				<< " interesting planes" << endl;
	}
	Inc = NEW_int(set_size * nb_blocks);
	for (i = 0; i < set_size * nb_blocks; i++) {
		Inc[i] = 0;
	}
	j = 0;
	for (h = 0; h < C->nb_types; h++) {
		f = C->type_first[h];
		l = C->type_len[h];
		a = C->data_sorted[f];
		if (a == m) {
			for (u = 0; u < l; u++) {
				a = C->data_sorted[f + u];
				idx = C->sorting_perm_inv[f + u];
				for (uu = 0; uu < a; uu++) {
					//i = Pts_on_plane[idx][uu];
					i = Intersections->Sets[idx][uu];
					Inc[i * nb_blocks + j] = 1;
				}
				j++;
			} // next u
		} // if
	} // next h

	// ToDo:
#if 0
	if (nb_blocks < 20) {

		cout << "we will draw an incidence picture" << endl;
		
		string fname_pic;
		geometry::incidence_structure *I;
		data_structures::partitionstack *Stack;
		
		I = NEW_OBJECT(geometry::incidence_structure);
		I->init_by_matrix(set_size, nb_blocks, Inc, 0 /* verbose_level */);
		Stack = NEW_OBJECT(data_structures::partitionstack);
		Stack->allocate(set_size + nb_blocks, 0 /* verbose_level */);
		Stack->subset_contiguous(set_size, nb_blocks);
		Stack->split_cell(0 /* verbose_level */);
		Stack->sort_cells();

		fname_pic = Iso->prefix + "_" + std::to_string(iso_cnt) + "_planes.tex";

		{
			ofstream fp_pic(fname_pic);

			ost << "\\input " << fname_pic << endl;
			I->latex_it(fp_pic, *Stack);
			ost << "\\\\" << endl;
		}
		FREE_OBJECT(Stack);
		FREE_OBJECT(I);
	}

	// compute TDO:
	{
		geometry::incidence_structure *I;
		data_structures::partitionstack *Stack;
		int depth = INT_MAX;
		
		I = NEW_OBJECT(geometry::incidence_structure);
		I->init_by_matrix(set_size, nb_blocks, Inc, 0 /* verbose_level */);
		Stack = NEW_OBJECT(data_structures::partitionstack);
		Stack->allocate(set_size + nb_blocks, 0 /* verbose_level */);
		Stack->subset_contiguous(set_size, nb_blocks);
		Stack->split_cell(0 /* verbose_level */);
		Stack->sort_cells();

		I->compute_TDO_safe(*Stack, depth, verbose_level + 2);
		
		string fname_row_scheme;
		string fname_col_scheme;


		fname_row_scheme = Iso->prefix + "_" + std::to_string(iso_cnt) + "_planes_row_scheme.tex";
		fname_col_scheme = Iso->prefix + "_" + std::to_string(iso_cnt) + "_planes_col_scheme.tex";

		{
			ofstream fp_row_scheme(fname_row_scheme);
			ofstream fp_col_scheme(fname_col_scheme);
			I->get_and_print_row_tactical_decomposition_scheme_tex(
				fp_row_scheme, false /* f_enter_math */,
				true /* f_print_subscripts */, *Stack);
			I->get_and_print_column_tactical_decomposition_scheme_tex(
				fp_col_scheme, false /* f_enter_math */,
				true /* f_print_subscripts */, *Stack);
		}


#if 0
		ost2 << "\\section*{Spread " << iso_cnt << "}" << endl << endl;

		longinteger_object go;
		Stab->group_order(go);

		ost2 << "Stabilizer has order " << go << "\\\\" << endl;
	
		ost2 << "\\bigskip" << endl;


		tally C0;
		C0.init(Orb.orbit_len, Orb.nb_orbits, false, 0);
		
		ost2 << "There are $" << Orb.nb_orbits << "$ orbits on the set.\\\\" << endl;
		ost2 << "The orbit type is $[";
		C0.print_bare_tex(ost2);
		ost2 << "]$\\\\" << endl;
		ost2 << "\\bigskip" << endl;

		ost2 << "Plane type of Klein-image is $(";
		C.print_bare_tex(ost2);
		ost2 << ")$" << endl << endl;
#endif


		ost << "\\bigskip" << endl << endl;
		ost << "\\[" << endl;
		ost << "\\input " << fname_row_scheme << endl;
		ost << "\\quad" << endl;
		ost << "\\input " << fname_col_scheme << endl;
		ost << "\\]" << endl;

		FREE_OBJECT(Stack);
		FREE_OBJECT(I);
	}
#endif

	FREE_int(Inc);
	
	FREE_OBJECTS(R);

#if 0
	for (i = 0; i < nb_planes; i++) {
		FREE_lint(Pts_on_plane[i]);
	}
	FREE_plint(Pts_on_plane);
	FREE_int(nb_pts_on_plane);
#endif

	FREE_OBJECT(Intersections);
	if (f_v) {
		cout << "spread_classify::klein done" << endl;
	}
}


void spread_classify::report2(
		isomorph::isomorph &Iso, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	string fname;

	if (f_v) {
		cout << "spread_classify::report2" << endl;
	}
	fname = "report_Spreads_q" + std::to_string(SD->q) + "_k" + std::to_string(SD->k) + ".tex";

	{
		ofstream f(fname);
		int f_book = true;
		int f_title = true;
		string title, author, extra_praeamble;

		int f_toc = true;
		int f_landscape = false;
		int f_12pt = false;
		int f_enlarged_page = true;
		int f_pagenumbers = true;
		other::l1_interfaces::latex_interface L;

		title = "$" + std::to_string(SD->k - 1) + "$-Spreads of PG($" + std::to_string(2 * SD->k - 1) + "," + std::to_string(SD->q) + "$)";
		author = "Orbiter";

		cout << "Writing file " << fname << " with "
				<< Iso.Folding->Reps->count << " spreads:" << endl;
		L.head(f, f_book, f_title,
			title, author,
			f_toc, f_landscape, f_12pt, f_enlarged_page, f_pagenumbers,
			extra_praeamble /* extra_praeamble */);

		report3(Iso, f, verbose_level);

		L.foot(f);

	}
	other::orbiter_kernel_system::file_io Fio;

	cout << "Written file " << fname << " of size "
			<< Fio.file_size(fname) << endl;

}

void spread_classify::report3(
		isomorph::isomorph &Iso,
		std::ostream &ost, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "spread_classify::report3" << endl;
	}

	int target_size = SD->order + 1;
	other::data_structures::sorting Sorting;

	ost << "\\chapter{Summary}" << endl << endl;
	ost << "There are " << Iso.Folding->Reps->count << " spreads." << endl << endl;


	//Iso.setup_and_open_solution_database(verbose_level - 1);

	int i, first, /*c,*/ id;
	int u, v, h, rep, tt;
	algebra::ring_theory::longinteger_object go;
	long int data[1000];



	algebra::ring_theory::longinteger_object *Ago, *Ago_induced;
	int *Ago_int;

	Ago = NEW_OBJECTS(algebra::ring_theory::longinteger_object, Iso.Folding->Reps->count);
	Ago_induced = NEW_OBJECTS(algebra::ring_theory::longinteger_object, Iso.Folding->Reps->count);
	Ago_int = NEW_int(Iso.Folding->Reps->count);


	for (h = 0; h < Iso.Folding->Reps->count; h++) {
		rep = Iso.Folding->Reps->rep[h];
		first = Iso.Lifting->flag_orbit_solution_first[rep];
		//c = Iso.starter_number[first];
		id = Iso.Lifting->orbit_perm[first];
		Iso.Lifting->load_solution(id, data, verbose_level - 1);

		groups::sims *Stab;
		
		Stab = Iso.Folding->Reps->stab[h];

		Iso.Folding->Reps->stab[h]->group_order(Ago[h]);
		Ago_int[h] = Ago[h].as_int();
		//f << "Stabilizer has order $";
		//go.print_not_scientific(f);
		if (f_v) {
			cout << "spread::print_isomorphism_types computing "
					"induced action on the set (in data)" << endl;
		}
		Iso.Folding->induced_action_on_set(Stab, data, 0 /*verbose_level*/);
		
			
		Iso.Folding->AA->group_order(Ago_induced[h]);
	}


	other::data_structures::tally C_ago;

	C_ago.init(Ago_int, Iso.Folding->Reps->count, false, 0);
	cout << "Classification by ago:" << endl;
	C_ago.print(false /*f_backwards*/);



	ost << "\\chapter{Invariants}" << endl << endl;

	ost << "Classification by automorphism group order: $";
	C_ago.print_bare_tex(ost, false /*f_backwards*/);
	ost << "$" << endl;
	ost << "\\\\" << endl;

	ost << "\\begin{center}" << endl;
	ost << "\\begin{tabular}{|c|l|}" << endl;
	ost << "\\hline" << endl;
	ost << "Ago & Isom. Types \\\\" << endl;
	ost << "\\hline" << endl;
	ost << "\\hline" << endl;

	int cnt, length, t, vv, *set;

	cnt = 0;
	for (u = C_ago.nb_types - 1; u >= 0; u--) {
		first = C_ago.type_first[u];
		length = C_ago.type_len[u];
		t = C_ago.data_sorted[first];

		ost << t << " & ";

		set = NEW_int(length);
		for (v = 0; v < length; v++, cnt++) {
			vv = first + v;
			i = C_ago.sorting_perm_inv[vv];
			set[v] = i;
		}

		Sorting.int_vec_heapsort(set, length);

		for (v = 0; v < length; v++, cnt++) {

			ost << set[v];

			if (v < length - 1) {
				ost << ",";
				if ((v + 1) % 10 == 0) {
					ost << "\\\\" << endl;
					ost << " & " << endl;
				}
			}
		}
		ost << "\\\\" << endl;
		if (u > 0) {
			ost << "\\hline" << endl;
		}
		FREE_int(set);
	}
	ost << "\\hline" << endl;
	ost << "\\end{tabular}" << endl;
	ost << "\\end{center}" << endl << endl;


	ost << "\\clearpage" << endl << endl;

	ost << "\\begin{center}" << endl;
	ost << "\\begin{tabular}{|r|r|r|r|r|r|}" << endl;
	ost << "\\hline" << endl;
	ost << "ID & Isom. Type & $|\\mbox{Aut}|$ & $|\\mbox{Aut}|$ "
			"(induced) & \\# Orbits & Orbit Type\\\\" << endl;
	ost << "\\hline" << endl;
	ost << "\\hline" << endl;

	cnt = 0;
	for (u = 0; u < C_ago.nb_types; u ++) {
		first = C_ago.type_first[u];
		length = C_ago.type_len[u];
		t = C_ago.data_sorted[first];

		set = NEW_int(length);
		for (v = 0; v < length; v++) {
			vv = first + v;
			i = C_ago.sorting_perm_inv[vv];
			set[v] = i;
		}

		Sorting.int_vec_heapsort(set, length);


		for (v = 0; v < length; v++) {
			vv = first + v;
			i = C_ago.sorting_perm_inv[vv];
			h = set[v];
			ost << setw(3) << first + v + 1 << " & ";
			ost << setw(3) << h << " & ";
			Ago[h].print_not_scientific(ost);
			ost << " & ";
			Ago_induced[h].print_not_scientific(ost);

			orbit_info_short(ost, Iso, h, verbose_level - 1);


			ost << "\\\\" << endl;
			cnt++;
			if ((cnt % 30) == 0) {
				ost << "\\hline" << endl;
				ost << "\\end{tabular}" << endl;
				ost << "\\end{center}" << endl << endl;
				ost << "\\begin{center}" << endl;
				ost << "\\begin{tabular}{|r|r|r|r|r|r|}" << endl;
				ost << "\\hline" << endl;
				ost << "ID & Isom. Type & $|\\mbox{Aut}|$ & $|\\mbox{Aut}|$ "
						"(induced) & \\# Orbits & Orbit Type\\\\" << endl;
				ost << "\\hline" << endl;
				ost << "\\hline" << endl;
			}
		}
		FREE_int(set);
	}

	ost << "\\hline" << endl;
	ost << "\\end{tabular}" << endl;
	ost << "\\end{center}" << endl << endl;


	ost << "\\chapter{The Spreads}" << endl << endl;

	ost << "\\clearpage" << endl << endl;


	for (h = 0; h < Iso.Folding->Reps->count; h++) {
		rep = Iso.Folding->Reps->rep[h];
		first = Iso.Lifting->flag_orbit_solution_first[rep];
		//c = Iso.starter_number[first];
		id = Iso.Lifting->orbit_perm[first];
		Iso.Lifting->load_solution(id, data, verbose_level - 1);


		ost << "\\section{Isomorphism type " << h << "}" << endl;
		ost << "\\bigskip" << endl;

		//f << "The ambient space has dimension "
		//<< Rk_of_span[h] << "\\\\" << endl;

		if (Iso.Folding->Reps->stab[h]) {
			Iso.Folding->Reps->stab[h]->group_order(go);
			ost << "Stabilizer has order $";
			go.print_not_scientific(ost);
			ost << "$\\\\" << endl;
		}
		else {
			//cout << endl;
		}

#if 0
		if (h == 35) {
			cout << "Isomorphism type 35:" << endl;
			cout << "rep=" << rep << endl;
			cout << "first=" << first << endl;
			cout << "id=" << id << endl;
			cout << "starter_number=" << c << endl;
			cout << "solution:" << endl;
			int_vec_print(cout, data, target_size);
			cout << endl;
		}
#endif

		groups::sims *Stab;
		
		Stab = Iso.Folding->Reps->stab[h];

		if (f_v) {
			cout << "spread::print_isomorphism_types computing "
					"induced action on the set (in data)" << endl;
		}
		Iso.Folding->induced_action_on_set(Stab, data, 0 /*verbose_level*/);
		
		algebra::ring_theory::longinteger_object go1;
			
		Iso.Folding->AA->group_order(go1);
		cout << "action " << Iso.Folding->AA->label << " computed, "
				"group order is " << go1 << endl;

		ost << "Order of the group that is induced on the "
				"collection of subspaces is ";
		ost << "$";
		go1.print_not_scientific(ost);
		ost << "$\\\\" << endl;
		

		groups::schreier Orb;
		//longinteger_object go2;
		
		Iso.Folding->AA->compute_all_point_orbits(Orb,
				Stab->gens, verbose_level - 2);
		ost << "With " << Orb.Forest->nb_orbits
				<< " orbits on the subspaces\\\\" << endl;

		other::data_structures::tally C_ol;

		C_ol.init(Orb.Forest->orbit_len, Orb.Forest->nb_orbits, false, 0);

		ost << "Orbit lengths: $";
		//int_vec_print(f, Orb.orbit_len, Orb.nb_orbits);
		C_ol.print_bare_tex(ost, false /*f_backwards*/);
		ost << "$ \\\\" << endl;

		ost << "Orbits: $";
		Orb.Forest->list_all_orbits_tex(ost);
		ost << "$ \\\\" << endl;

	
		tt = (target_size + 3) / 4;

		ost << "The subspaces by ranks:\\\\" << endl;
		ost << "\\begin{center}" << endl;

		for (u = 0; u < 4; u++) {
			ost << "\\begin{tabular}[t]{|c|c|}" << endl;
			ost << "\\hline" << endl;
			ost << "$i$ & Rank \\\\" << endl;
			ost << "\\hline" << endl;
			for (i = 0; i < tt; i++) {
				v = u * tt + i;
				if (v < target_size) {
					ost << "$" << v << "$ & $" << data[v] << "$ \\\\" << endl;
				}
			}
			ost << "\\hline" << endl;
			ost << "\\end{tabular}" << endl;
		}
		ost << "\\end{center}" << endl;

		ost << "The subspaces:\\\\" << endl;
		for (i = 0; i < target_size; i++) {
			SD->Grass->unrank_lint(data[i], 0/*verbose_level - 4*/);
			if ((i % 4) == 0) {
				if (i) {
					ost << "$$" << endl;
				}
				ost << "$$" << endl;
			}
			ost << "\\left[" << endl;
			ost << "\\begin{array}{c}" << endl;
			for (u = 0; u < SD->k; u++) {
				for (v = 0; v < SD->n; v++) {
					ost << SD->Grass->M[u * SD->n + v];
				}
				ost << "\\\\" << endl;
			}
			ost << "\\end{array}" << endl;
			ost << "\\right]" << endl;
		}
		ost << "$$" << endl;


		report_stabilizer(Iso, ost, h /* orbit */, 0 /* verbose_level */);

		if (SD->k == 2) {

			other::data_structures::tally *C;

			if (f_v) {
				cout << "spread_classify::report3 "
						"before klein" << endl;
			}
			klein(/*ost, &Iso,*/ h, /*Stab, Orb,*/ data, Iso.size,
					C,
					verbose_level);
			if (f_v) {
				cout << "spread_classify::report3 "
						"after klein" << endl;
			}

			FREE_OBJECT(C);
		}

		ost << "" << endl;
		ost << "\\bigskip" << endl;
		ost << "" << endl;
		ost << "Induced action on the orbits:\\\\" << endl;
		ost << "$$" << endl;
		ost << "\\begin{array}{|c|c|c|c|}" << endl;
		ost << "\\hline" << endl;
		ost << "\\mbox{Orbit} & \\mbox{Length} & \\mbox{Induced} "
				"& \\mbox{Kernel} \\\\" << endl;
		ost << "\\hline" << endl;
		for (i = 0; i < Orb.Forest->nb_orbits; i++) {
			int fst, len, j;
			fst = Orb.Forest->orbit_first[i];
			len = Orb.Forest->orbit_len[i];

			cout << "inducing action on orbit " << i
					<< " of length " << len << endl;
			ost << i << " & " << len << " & ";
			long int *set;
			actions::action *A1;
			algebra::ring_theory::longinteger_object go1, gok;

			set = NEW_lint(len);
			//A1 = NEW_OBJECT(action);
			for (j = 0; j < len; j++) {
				set[j] = data[Orb.Forest->orbit[fst + j]];
			}


			std::string label_of_set;
			std::string label_of_set_tex;

			label_of_set = "_spread";
			label_of_set_tex = "\\_spread";


			A1 = Iso.A->Induced_action->create_induced_action_by_restriction(
					Stab,
					len, set, label_of_set, label_of_set_tex,
					true,
					0/*verbose_level*/);
			if (f_v) {
				cout << "after induced_action_by_restriction" << endl;
			}
			A1->group_order(go1);
			A1->Kernel->group_order(gok);
			cout << "induced group order " << go1
					<< " kernel order " << gok << endl;

			ost << go1 << " & " << gok << "\\\\" << endl;

			FREE_lint(set);
			FREE_OBJECT(A1);
		}
		ost << "\\hline" << endl;
		ost << "\\end{array}" << endl;
		ost << "$$" << endl;



		for (i = 0; i < Orb.Forest->nb_orbits; i++) {
			int fst, len, j;
			fst = Orb.Forest->orbit_first[i];
			len = Orb.Forest->orbit_len[i];

			cout << "inducing action on orbit " << i
					<< " of length " << len << endl;
			ost << "Generators for the kernel in the action "
					"on orbit " << i << " are:";
			long int *set;
			actions::action *A1;
			data_structures_groups::vector_ge *gens;
			int *tl;
			algebra::ring_theory::longinteger_object go1, gok;

			set = NEW_lint(len);
			//A1 = NEW_OBJECT(action);
			gens = NEW_OBJECT(data_structures_groups::vector_ge);
			tl = NEW_int(Iso.A_base->base_len());
			for (j = 0; j < len; j++) {
				set[j] = data[Orb.Forest->orbit[fst + j]];
			}

			std::string label_of_set;
			std::string label_of_set_tex;

			label_of_set = "_spread";
			label_of_set_tex = "\\_spread";

			A1 = Iso.A->Induced_action->create_induced_action_by_restriction(
					Stab,
					len, set, label_of_set, label_of_set_tex,
					true,
					0/*verbose_level*/);
			if (f_v) {
				cout << "after induced_action_by_restriction" << endl;
			}
			A1->group_order(go1);
			A1->Kernel->group_order(gok);
			cout << "induced group order " << go1
					<< " kernel order " << gok << endl;
			A1->Kernel->extract_strong_generators_in_order(*gens, tl, 0);

			if (gens->len == 0) {
				ost << " No generators\\\\" << endl;
			}
			for (j = 0; j < gens->len; j++) {
		

				ost << "$$ g_{" << j + 1 << "}=" << endl;
				A->Group_element->element_print_latex(gens->ith(j), ost);
				ost << "$$" << endl;
			}
			
			FREE_lint(set);
			FREE_OBJECT(A1);
			FREE_OBJECT(gens);
			FREE_int(tl);
		}


	}

	//Iso.close_solution_database(verbose_level - 1);

	string prefix;
	string label_of_structure_plural;

	prefix = "Spreads_" + std::to_string(SD->q) + "_" + std::to_string(SD->k);
	label_of_structure_plural = "Spreads";



	isomorph::isomorph_global IG;

	IG.init(Iso.A_base, Iso.A, Iso.Sub->gen, verbose_level);

	IG.report_data_in_source_code_inside_tex(Iso,
		prefix, label_of_structure_plural, ost, verbose_level);



	FREE_int(Ago_int);
	FREE_OBJECTS(Ago);
	FREE_OBJECTS(Ago_induced);

	if (f_v) {
		cout << "spread_classify::report3 done" << endl;
	}
}


void spread_classify::all_cooperstein_thas_quotients(
		isomorph::isomorph &Iso, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int h;
	string fname;
	int cnt = 0;

	if (f_v) {
		cout << "spread_classify::all_cooperstein_thas_quotients" << endl;
	}


	//Iso.setup_and_open_solution_database(verbose_level - 1);


	fname = "quotients_q" + std::to_string(SD->order) + ".txt";
	{
		ofstream f(fname);


		for (h = 0; h < Iso.Folding->Reps->count; h++) {

			cooperstein_thas_quotients(Iso, f, h, cnt, verbose_level - 1);

		}


		f << -1 << endl;
	}
	other::orbiter_kernel_system::file_io Fio;

	cout << "Written file " << fname << " of size "
			<< Fio.file_size(fname) << endl;


	//Iso.close_solution_database(verbose_level - 1);

	if (f_v) {
		cout << "spread::all_cooperstein_thas_quotients done" << endl;
	}
}



void spread_classify::cooperstein_thas_quotients(
		isomorph::isomorph &Iso,
		std::ofstream &f, int h, int &cnt,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int rep, first, /*c,*/ id;
	groups::sims *Stab;
	long int data[1000];
	long int data2[1000];
	int u, fst, orbit_length, i, idx, i0, j, the_point, pivot, rem;
	long int a, b;
	int *M;
	int *vec1;
	int *vec2;
	long int **Pts;
	int nb_points = 0;
	int *List;
	geometry::projective_geometry::grassmann *Gr;
	algebra::ring_theory::longinteger_domain Dom;
	algebra::number_theory::number_theory_domain NT;
	other::data_structures::sorting Sorting;
	other::orbiter_kernel_system::file_io Fio;



	if (f_v ) {
		cout << "spread_classify::cooperstein_thas_quotients" << endl;
		cout << "spread_classify::cooperstein_thas_quotients h=" << h << endl;
	}

	rep = Iso.Folding->Reps->rep[h];
	first = Iso.Lifting->flag_orbit_solution_first[rep];
	//c = Iso.starter_number[first];
	id = Iso.Lifting->orbit_perm[first];
	Iso.Lifting->load_solution(id, data, verbose_level - 1);


	Stab = Iso.Folding->Reps->stab[h];

	groups::schreier Orb;
	algebra::ring_theory::longinteger_object go;
	algebra::ring_theory::longinteger_object stab_order;
		
	Stab->group_order(go);

	if (f_v) {
		cout << "spread_classify::cooperstein_thas_quotients "
				"Isomorphism type " << h << " with automorphism group "
						"of order " << go << ":" << endl;
	}

	if (f_vv) {
		cout << "spread_classify::cooperstein_thas_quotients "
				"before compute_all_point_orbits" << endl;
	}

	Iso.A_base->compute_all_point_orbits(Orb,
			Stab->gens, 0 /*verbose_level - 2*/);

	if (f_vv) {
		cout << "spread_classify::cooperstein_thas_quotients There are "
				<< Orb.Forest->nb_orbits << " orbits on points" << endl;
	}


	int k, n, order;

	k = SD->k;
	n = SD->n;
	order = SD->order;
	
	M = NEW_int(k * n);
	vec1 = NEW_int(n);
	vec2 = NEW_int(n);
	Pts = NEW_plint(order + 1);
	List = NEW_int(order);
	Gr = NEW_OBJECT(geometry::projective_geometry::grassmann);

	Gr->init(n - 1, k, SD->F, 0 /* verbose_level */);
	for (i = 0; i < order + 1; i++) {
		SD->Grass->unrank_lint_here(M, data[i], 0/*verbose_level - 4*/);
		SD->F->Projective_space_basic->all_PG_elements_in_subspace(
				M, k, n,
				Pts[i], nb_points, 0 /* verbose_level */);
		Sorting.lint_vec_heapsort(Pts[i], nb_points);
	}

	for (u = 0; u < Orb.Forest->nb_orbits; u++) {
		fst = Orb.Forest->orbit_first[u];
		orbit_length = Orb.Forest->orbit_len[u];
		
		the_point = Orb.Forest->orbit[fst];
		Dom.integral_division_by_int(go, orbit_length, stab_order, rem);

		if (f_vv) {
			cout << "spread_classify::cooperstein_thas_quotients Orbit " << u
					<< " is represented by point " << the_point
					<< " orbit length = " << orbit_length
					<< " stabilizer order before " << go
					<< " after " << stab_order << endl;
		}


		SD->F->Projective_space_basic->PG_element_unrank_modified(
				vec1, 1, n, the_point);
		SD->F->Projective_space_basic->PG_element_normalize_from_front(
				vec1, 1, n);
		pivot = Int_vec_find_first_nonzero_entry(vec1, n);

		for (i = 0; i < order + 1; i++) {
			if (Sorting.lint_vec_search(
					Pts[i], nb_points, the_point, idx, 0)) {
				break;
			}
		}
		if (i == order + 1) {
			cout << "spread_classify::cooperstein_thas_quotients "
					"Did not find the point" << endl;
			exit(1);
		}
		i0 = i;
		j = 0;
		for (i = 0; i < order + 1; i++) {
			if (i != i0) {
				List[j++] = i;
			}
		}
		if (j != order) {
			cout << "spread_classify::cooperstein_thas_quotients "
					"j != order" << endl;
			exit(1);
		}
		for (i = 0; i < order; i++) {
			a = data[List[i]];
			SD->Grass->unrank_lint_here(M, a, 0/*verbose_level - 4*/);
			Int_vec_copy(vec1, vec2, n);
			for (j = 0; j < k; j++) {
				SD->F->Linear_algebra->Gauss_step(
						vec2, M + j * n, n, pivot,
						0 /* verbose_level*/);
					// afterwards: v2[idx] = 0 and
					// v1,v2 span the same space as before
					// v1 is not changed if v1[idx] is nonzero
			}

#if 1
			// delete column 'pivot' in the k x n matrix M.
			// Afterwards, the matrix is k x (n - 1)

			other::orbiter_kernel_system::Orbiter->Int_vec->matrix_delete_column_in_place(M, k, n, pivot);
#endif

			if (f_vv) {
				cout << "spread_classify::cooperstein_thas_quotients "
						"the reduction "
						"of the " << i << "-th matrix is:" << endl;
				Int_matrix_print(M, k, n - 1);
			}

			b = Gr->rank_lint_here(M, 0/*verbose_level - 4*/);
			data2[i] = b;
		}

		if (f_vv) {
			cout << "spread_classify::cooperstein_thas_quotients "
					"The quotient "
					"system with respect to orbit " << u << " / "
					<< Orb.Forest->nb_orbits << " is:" << endl;
			Lint_vec_print(cout, data2, order);
			cout << endl;
		}


		f << h << " " << u << " " << the_point << " " << orbit_length << " ";
		go.print_not_scientific(f);
		f << " ";
		stab_order.print_not_scientific(f);
		f << " ";
		for (i = 0; i < order; i++) {
			f << " " << data2[i];
		}
		f << endl;



		string fname = "quotient_q"
				+ std::to_string(NT.i_power_j(SD->q, k)) + "_iso" + std::to_string(h)
				+ "_nb" + std::to_string(u)
				+ "_orbit_length" + std::to_string(orbit_length) + ".txt";

		Fio.write_set_to_file(fname, data2, order, 0 /* verbose_level*/);
		cnt++;


	} // next u

	FREE_int(M);
	FREE_int(vec1);
	FREE_int(vec2);
	for (i = 0; i < order + 1; i++) {
		FREE_lint(Pts[i]);
	}
	FREE_plint(Pts);
	FREE_int(List);
	FREE_OBJECT(Gr);
	if (f_v ) {
		cout << "spread_classify::cooperstein_thas_quotients done" << endl;
	}
}

void spread_classify::orbit_info_short(
		std::ostream &ost, isomorph::isomorph &Iso,
		int h, int verbose_level)
{
	int rep, first, /*c,*/ id;

	groups::sims *Stab;
		
	long int data[1000];

	rep = Iso.Folding->Reps->rep[h];
	first = Iso.Lifting->flag_orbit_solution_first[rep];
	//c = Iso.starter_number[first];
	id = Iso.Lifting->orbit_perm[first];
	Iso.Lifting->load_solution(id, data, verbose_level - 1);


	Stab = Iso.Folding->Reps->stab[h];

	Iso.Folding->induced_action_on_set(Stab, data, 0 /*verbose_level*/);
		
	algebra::ring_theory::longinteger_object go1;
			
	Iso.Folding->AA->group_order(go1);
	cout << "action " << Iso.Folding->AA->label << " computed, "
			"group order is " << go1 << endl;


#if 0
	f << "Order of the group that is induced on the "
			"collection of subspaces is ";
	f << "$";
	go1.print_not_scientific(f);
	f << "$\\\\" << endl;
#endif	

	groups::schreier Orb;
	//longinteger_object go2;
		
	Iso.Folding->AA->compute_all_point_orbits(Orb, Stab->gens, 0 /*verbose_level - 2*/);
	//f << "With " << Orb.nb_orbits << " orbits on the subspaces\\\\" << endl;

	ost << " & " << Orb.Forest->nb_orbits << " & ";

	other::data_structures::tally C_ol;

	C_ol.init(Orb.Forest->orbit_len, Orb.Forest->nb_orbits, false, 0);

	//f << "Orbit lengths: ";
	//int_vec_print(f, Orb.orbit_len, Orb.nb_orbits);
	ost << "$";
	C_ol.print_bare_tex(ost, false /*f_backwards*/);
	ost << "$";
	//f << " \\\\" << endl;
	
}



void spread_classify::report_stabilizer(
		isomorph::isomorph &Iso,
		std::ostream &ost, int orbit, int verbose_level)
{
	groups::sims *Stab;
	algebra::ring_theory::longinteger_object go;
	int i;

	Stab = Iso.Folding->Reps->stab[orbit];
	Stab->group_order(go);

	ost << "The stabilizer of order $" << go << "$ is generated by:\\\\" << endl;
	for (i = 0; i < Stab->gens.len; i++) {
		
		int n, ord;
		
		//fp = NEW_int(A->degree);
		n = A->Group_element->count_fixed_points(Stab->gens.ith(i), 0);
		//cout << "with " << n << " fixed points" << endl;
		//FREE_int(fp);

		ord = A->Group_element->element_order(Stab->gens.ith(i));

		ost << "$$ g_{" << i + 1 << "}=" << endl;
		A->Group_element->element_print_latex(Stab->gens.ith(i), ost);
		ost << "$$" << endl << "of order $" << ord << "$ and with "
				<< n << " fixed points" << endl;
	}
}



// #############################################################################
// global functions:
// #############################################################################




#if 0
static int spread_check_function_callback(int len,
		long int *S, void *data, int verbose_level)
{
	spread_classify *Spread = (spread_classify *) data;
	int f_OK;
	
	f_OK = Spread->check_function(len, S, verbose_level);
	return f_OK;
}

static void spread_callback_report(isomorph *Iso, void *data, int verbose_level)
{
	spread_classify *Spread = (spread_classify *) data;
	
	Spread->report2(*Iso, verbose_level);
}

static void spread_callback_make_quotients(isomorph *Iso,
		void *data, int verbose_level)
{
	spread_classify *Spread = (spread_classify *) data;
	
	Spread->all_cooperstein_thas_quotients(*Iso, verbose_level);
}

static void callback_spread_print(std::ostream &ost, int len, long int *S, void *data)
{
	spread_classify *Spread = (spread_classify *) data;

	Spread->print_spread(ost, S, len);
}
#endif

}}}


