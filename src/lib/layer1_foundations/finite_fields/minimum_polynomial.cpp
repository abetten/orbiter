/*
 * minimum_polynomial.cpp
 *
 *  Created on: Dec 18, 2022
 *      Author: betten
 */



#include "foundations.h"

using namespace std;



namespace orbiter {
namespace layer1_foundations {
namespace field_theory {



minimum_polynomial::minimum_polynomial()
{
	F = NULL;

	order_subfield = 0;
	subgroup_index = 0;
	e1 = 0;
	q1 = 0;

	M = NULL;
	MM = NULL;
	K = NULL;
	base_cols = NULL;
	kernel_m = 0;
	kernel_n = 0;
	min_poly_rank = 0;

	// min_poly_rank_as_string;
}


minimum_polynomial::~minimum_polynomial()
{

}

void minimum_polynomial::compute_subfield_polynomial(
		finite_field *F,
		int order_subfield, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);

	if (f_v) {
		cout << "minimum_polynomial::compute_subfield_polynomial "
				"for subfield of order " << order_subfield << endl;
	}

	minimum_polynomial::order_subfield = order_subfield;
	minimum_polynomial::F = F;
	int p1;

	number_theory::number_theory_domain NT;

	if (f_v) {
		cout << "minimum_polynomial::compute_subfield_polynomial "
				"for subfield of order " << order_subfield << endl;
	}
	NT.factor_prime_power(order_subfield, p1, e1);
	if (p1 != F->p) {
		cout << "minimum_polynomial::compute_subfield_polynomial "
				"the subfield must have the same characteristic" << endl;
		exit(1);
	}
	if ((F->e % e1)) {
		cout << "minimum_polynomial::compute_subfield_polynomial "
				"is not a subfield" << endl;
		exit(1);
	}

	finite_field GFp;
	GFp.finite_field_init_small_order(F->p,
			false /* f_without_tables */,
			false /* f_compute_related_fields */,
			0);

	ring_theory::unipoly_domain FX(&GFp);
	ring_theory::unipoly_object m;

	FX.create_object_by_rank_string(m, F->my_poly, 0/*verbose_level*/);
	ring_theory::unipoly_domain Fq(&GFp, m, verbose_level - 1);


	geometry::geometry_global Gg;
	int i;
	int j;
	int jj;
	int rk;


	M = NEW_int(F->e * (e1 + 1));
	MM = NEW_int(F->e * (e1 + 1));
	Int_vec_zero(M, F->e * (e1 + 1));

	K = NEW_int(F->e);
	base_cols = NEW_int(F->e);
	q1 = NT.i_power_j(F->p, e1);
	subgroup_index = (F->q - 1) / (q1 - 1);
	if (f_v) {
		cout << "minimum_polynomial::compute_subfield_polynomial "
				"subfield " << F->p << "^" << e1 << " : subgroup_index = "
			<< subgroup_index << endl;
	}
	for (i = 0; i <= e1; i++) {
		j = i * subgroup_index;
		jj = F->alpha_power(j);
		Gg.AG_element_unrank(F->p, M + i, e1 + 1, F->e, jj);
		{
			ring_theory::unipoly_object elt;

			Fq.create_object_by_rank(elt, jj, 0 /*verbose_level*/);
			if (f_v) {
				cout << i << " : " << j << " : " << jj << " : ";
				Fq.print_object(elt, cout);
				cout << endl;
			}
			Fq.delete_object(elt);
		}
	}

	if (f_v) {
		cout << "minimum_polynomial::compute_subfield_polynomial M=" << endl;
		Int_vec_print_integer_matrix_width(
				cout, M,
				F->e, e1 + 1, e1 + 1, GFp.log10_of_q);
	}

	Int_vec_copy(M, MM, F->e * (e1 + 1));

	rk = GFp.Linear_algebra->Gauss_simple(
			MM, F->e, e1 + 1,
		base_cols, 0/*verbose_level*/);
	if (f_vv) {
		cout << "minimum_polynomial::compute_subfield_polynomial after Gauss=" << endl;
		Int_vec_print_integer_matrix_width(
				cout, MM,
				F->e, e1 + 1, e1 + 1, GFp.log10_of_q);
		cout << "rk=" << rk << endl;
	}
	if (rk != e1) {
		cout << "minimum_polynomial::compute_subfield_polynomial fatal: rk != e1" << endl;
		cout << "rk=" << rk << endl;
		exit(1);
	}

	GFp.Linear_algebra->matrix_get_kernel(
			MM, F->e, e1 + 1, base_cols, rk,
		kernel_m, kernel_n, K, 0 /* verbose_level */);

	if (f_vv) {
		cout << "kernel_m=" << kernel_m << endl;
		cout << "kernel_n=" << kernel_n << endl;
	}
	if (kernel_n != 1) {
		cout << "kernel_n != 1" << endl;
		exit(1);
	}
	if (K[e1] == 0) {
		cout << "K[e1] == 0" << endl;
		exit(1);
	}
	if (K[e1] != 1) {
		int a;
		a = GFp.inverse(K[e1]);
		for (i = 0; i < e1 + 1; i++) {
			K[i] = GFp.mult(a, K[i]);
		}
	}
#if 0
	if (f_latex) {
		ost << "Right nullspace generated by:\\\\" << endl;
		ost << "$$" << endl;
		Int_vec_print(ost, K, e1 + 1);
		ost << "$$" << endl;
	}
#endif

	if (f_vv) {
		cout << "minimum_polynomial::compute_subfield_polynomial the relation is " << endl;
		Int_vec_print(cout, K, e1 + 1);
		cout << endl;
	}

	min_poly_rank = Gg.AG_element_rank(F->p, K, 1, e1 + 1);

	min_poly_rank_as_string = std::to_string(min_poly_rank);

	if (f_v) {
		ring_theory::unipoly_object elt;

		FX.create_object_by_rank(
				elt, min_poly_rank, verbose_level);
		cout << "minimum_polynomial::compute_subfield_polynomial "
				"subfield of order " << NT.i_power_j(F->p, e1)
				<< " : " << min_poly_rank << " = ";
		Fq.print_object(elt, cout);
		cout << endl;
		Fq.delete_object(elt);
	}

	if (f_v) {
		cout << "minimum_polynomial::compute_subfield_polynomial done" << endl;
	}
}

void minimum_polynomial::report_table(std::ostream &ost)
{
	ost << "The power table shows $(\\alpha^d)^i$ for $i=0,1,\\ldots,e$ where $q=p^{e}$:" << endl;
	ost << "$$" << endl;
	ost << "\\begin{array}{|c|c|c|c|}" << endl;
	ost << "\\hline" << endl;
	ost << "i & i\\cdot d  & \\alpha^{id} & \\mbox{vector} \\\\" << endl;
	ost << "\\hline" << endl;

	int h, i, j, jj;

	for (i = 0; i <= e1; i++) {
		ost << i;
		ost << " & ";
		j = i * subgroup_index;
		ost << j;
		ost << " & ";
		jj = F->alpha_power(j);
		ost << jj;
		ost << " & ";
		ost << "(";
		for (h = F->e - 1; h >= 0; h--) {
			ost << M[h * (e1 + 1) + i];
			if (h) {
				ost << ",";
			}
		}
		ost << ")";
		ost << "\\\\" << endl;
		//Gg.AG_element_unrank(p, M + i, e1 + 1, e, jj);
	}

	ost << "\\hline" << endl;
	ost << "\\end{array}" << endl;
	ost << "$$" << endl;

}

}}}

