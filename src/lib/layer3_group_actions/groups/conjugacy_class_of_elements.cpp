/*
 * conjugacy_class_of_elements.cpp
 *
 *  Created on: Nov 3, 2023
 *      Author: betten
 */





#include "layer1_foundations/foundations.h"
#include "layer2_discreta/discreta.h"
#include "group_actions.h"


using namespace std;


namespace orbiter {
namespace layer3_group_actions {
namespace groups {


conjugacy_class_of_elements::conjugacy_class_of_elements()
{
	Record_birth();

	Class_data = NULL;
	idx = 0;
	group_G = NULL;

	gens = NULL;
	//ring_theory::longinteger_object go1;
	//ring_theory::longinteger_object Class_size;
	//ring_theory::longinteger_object centralizer_order;
	goi = 0;
	sub_idx = 0;
	nice_gens = NULL;
	ngo = 0;
	nb_perms = 0;
	N_gens = NULL;
	nice_gens_N = NULL;
}

conjugacy_class_of_elements::~conjugacy_class_of_elements()
{
	Record_death();
	if (nice_gens_N) {
		FREE_OBJECT(nice_gens_N);
	}
	if (nice_gens) {
		FREE_OBJECT(nice_gens);
	}
	if (N_gens) {
		FREE_OBJECT(N_gens);
	}
	if (gens) {
		FREE_OBJECT(gens);
	}
}

void conjugacy_class_of_elements::init(
		interfaces::conjugacy_classes_and_normalizers *Class_data,
		int idx,
		groups::sims *group_G,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "conjugacy_class_of_elements::init" << endl;
	}

	//cout << "The conjugacy class " << idx << " / " << nb_classes << " is:" << endl;


	conjugacy_class_of_elements::Class_data = Class_data;
	conjugacy_class_of_elements::idx = idx;
	conjugacy_class_of_elements::group_G = group_G;



	algebra::ring_theory::longinteger_object go;
	algebra::ring_theory::longinteger_domain D;

	group_G->group_order(go);


	goi = Class_data->class_order_of_element[idx];
	ngo = Class_data->class_normalizer_order[idx];


	if (f_v) {
		cout << "conjugacy_class_of_elements::init goi=" << goi << endl;
		cout << "conjugacy_class_of_elements::init ngo=" << ngo << endl;
	}


	gens = NEW_OBJECT(groups::strong_generators);


	// create strong generators for the cyclic group generated by the idx-th class rep
	// nice_gens will contain the single generator only.
	if (f_v) {
		cout << "conjugacy_class_of_elements::init computing H, "
			"before gens->init_from_permutation_representation" << endl;
	}
	gens->init_from_permutation_representation(
			Class_data->A, group_G,
			Class_data->perms + idx * Class_data->A->degree,
			1, goi, nice_gens,
			verbose_level - 1);

	if (f_v) {
		cout << "conjugacy_class_of_elements::init computing H, "
			"after gens->init_from_permutation_representation" << endl;
	}

	Class_size.create(Class_data->class_size[idx]);

	D.integral_division_exact(
			go, Class_size, centralizer_order);





	nb_perms = Class_data->class_normalizer_number_of_generators[idx];

	//int *class_normalizer_order;
	//int *class_normalizer_number_of_generators;
	//int **normalizer_generators_perms;

	if (f_v) {
		cout << "conjugacy_class_of_elements::init computing N, "
			"before gens->init_from_permutation_representation" << endl;
	}
	N_gens = NEW_OBJECT(groups::strong_generators);
	N_gens->init_from_permutation_representation(
			Class_data->A, group_G,
			Class_data->normalizer_generators_perms[idx],
			nb_perms, ngo, nice_gens_N,
			verbose_level - 1);
	if (f_v) {
		cout << "conjugacy_class_of_elements::init computing N, "
			"after gens->init_from_permutation_representation" << endl;
	}

	if (f_v) {
		cout << "class " << idx << " / " << Class_data->nb_classes
			<< " size = " << Class_data->class_size[idx]
			<< " order of element = " << Class_data->class_order_of_element[idx]
			<< " centralizer order = " << centralizer_order
			<< " normalizer order = " << ngo
			<< " : " << endl;
		cout << "conjugacy_class_of_elements::init created "
				"generators for a group" << endl;
		gens->print_generators(cout, verbose_level - 1);
		gens->print_generators_as_permutations();
	}
	gens->group_order(go1);
	if (f_v) {
		cout << "conjugacy_classes_and_normalizers::report "
				"The group has order " << go1 << endl;
	}

#if 0
	fp << "\\bigskip" << endl;
	fp << "\\subsection*{Class " << idx << " / "
			<< Class_data->nb_classes << "}" << endl;
	fp << "Order of element = " << Class_data->class_order_of_element[idx]
			<< "\\\\" << endl;
	fp << "Class size = " << Class_data->class_size[idx] << "\\\\" << endl;
	fp << "Centralizer order = " << centralizer_order
			<< "\\\\" << endl;
	fp << "Normalizer order = " << ngo
			<< "\\\\" << endl;

	int *Elt = NULL;


	cout << "latex output element: " << endl;

	if (Class_data->class_order_of_element[idx] > 1) {
		Elt = nice_gens->ith(0);
		fp << "Representing element is" << endl;

		string label;

		label = "c_{" + std::to_string(idx) + "} = ";

		Class_data->A->Group_element->element_print_latex_with_extras(Elt, label, fp);

#if 0

		fp << "$$" << endl;
		element_print_latex(Elt, fp);
		fp << "$$" << endl;
#endif

		fp << "$";
		Class_data->A->Group_element->element_print_for_make_element(Elt, fp);
		fp << "$\\\\" << endl;



	}

	cout << "latex output normalizer: " << endl;


	fp << "The normalizer is generated by:\\\\" << endl;
	N_gens->print_generators_tex(fp);
#endif


#if 0
	if (class_order_of_element[i] > 1) {
		fp << "The fix structure is:\\\\" << endl;
		PA->report_fixed_objects_in_PG_3_tex(
				Elt, fp,
				verbose_level);

		fp << "The orbit structure is:\\\\" << endl;
		PA->report_orbits_in_PG_3_tex(
			Elt, fp,
			verbose_level);
	}
	if (class_order_of_element[i] > 1) {

		PA->report_decomposition_by_single_automorphism(
				Elt, fp,
				verbose_level);
		// PA->
		//action *A; // linear group PGGL(d,q)
		//action *A_on_lines; // linear group PGGL(d,q) acting on lines


	}
#endif

	//FREE_int(class_data->normalizer_generators_perms[i]);

	if (f_v) {
		cout << "conjugacy_class_of_elements::init" << endl;
	}

}

std::string conjugacy_class_of_elements::stringify_representative_coded(
	int verbose_level)
{
	string s;
	int *Elt;

	Elt = nice_gens->ith(0);

	s = Class_data->A->Group_element->element_stringify_code_for_make_element(Elt);
	return s;
}

void conjugacy_class_of_elements::single_class_data(
		std::vector<std::string > &data, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "conjugacy_class_of_elements::single_class_data" << endl;
	}

	string s, str;

	s = std::to_string(idx);

	data.push_back(s);

	s = std::to_string(goi);

	data.push_back(s);
	char c[2];

	c[0] = 'A' + sub_idx;
	c[1] = 0;

	str.assign(c);

	s = std::to_string(goi) + str;

	data.push_back(s);

	s = Class_size.stringify();
	data.push_back(s);

	s = centralizer_order.stringify();
	data.push_back(s);

	s = std::to_string(ngo);
	data.push_back(s);

	if (f_v) {
		cout << "conjugacy_class_of_elements::single_class_data done" << endl;
	}
}




void conjugacy_class_of_elements::report_single_class(
		std::ofstream &ost, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "conjugacy_class_of_elements::report_single_class" << endl;
	}

	if (f_v) {
		cout << "class " << idx << " / " << Class_data->nb_classes
			<< " size = " << Class_data->class_size[idx]
			<< " order of element = " << Class_data->class_order_of_element[idx]
			<< " centralizer order = " << centralizer_order
			<< " normalizer order = " << ngo
			<< " : " << endl;
		cout << "conjugacy_classes_and_normalizers::report created "
				"generators for a group" << endl;
		gens->print_generators(cout, verbose_level - 1);
		gens->print_generators_as_permutations();
	}
	gens->group_order(go1);
	if (f_v) {
		cout << "conjugacy_classes_and_normalizers::report "
			"The group has order " << go1 << endl;
	}

	ost << "\\bigskip" << endl;
	ost << "\\subsection*{Class " << idx << " / "
			<< Class_data->nb_classes << "}" << endl;
	ost << "Order of element = " << Class_data->class_order_of_element[idx]
			<< "\\\\" << endl;
	ost << "Class size = " << Class_data->class_size[idx] << "\\\\" << endl;
	ost << "Centralizer order = " << centralizer_order
			<< "\\\\" << endl;
	ost << "Normalizer order = " << ngo
			<< "\\\\" << endl;

	int *Elt = NULL;


	if (f_v) {
		cout << "conjugacy_class_of_elements::report_single_class "
				"latex output element: " << endl;
	}

	if (true /*Class_data->class_order_of_element[idx] > 1*/) {
		Elt = nice_gens->ith(0);
		ost << "Representing element is" << endl;

		string label;

		label = "c_{" + std::to_string(idx) + "} = ";

		Class_data->A->Group_element->element_print_latex_with_extras(Elt, label, ost);

#if 0

		fp << "$$" << endl;
		element_print_latex(Elt, fp);
		fp << "$$" << endl;
#endif

		string s_element_coded;

		s_element_coded = Class_data->A->Group_element->element_stringify_code_for_make_element(Elt);

		ost << "$";
		ost << s_element_coded;
		//Class_data->A->Group_element->element_print_for_make_element(Elt, fp);
		ost << "$\\\\" << endl;



	}

	if (f_v) {
		cout << "conjugacy_class_of_elements::report_single_class "
				"latex output normalizer: " << endl;
	}


	ost << "The normalizer is generated by:\\\\" << endl;
	N_gens->print_generators_tex(ost);


#if 0
	if (class_order_of_element[i] > 1) {
		fp << "The fix structure is:\\\\" << endl;
		PA->report_fixed_objects_in_PG_3_tex(
				Elt, fp,
				verbose_level);

		fp << "The orbit structure is:\\\\" << endl;
		PA->report_orbits_in_PG_3_tex(
			Elt, fp,
			verbose_level);
	}
	if (class_order_of_element[i] > 1) {

		PA->report_decomposition_by_single_automorphism(
				Elt, fp,
				verbose_level);
		// PA->
		//action *A; // linear group PGGL(d,q)
		//action *A_on_lines; // linear group PGGL(d,q) acting on lines


	}
#endif

	if (f_v) {
		cout << "conjugacy_class_of_elements::report_single_class done" << endl;
	}

}



}}}




