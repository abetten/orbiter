/*
 * conjugacy_class_of_subgroups.cpp
 *
 *  Created on: Sep 24, 2024
 *      Author: betten
 */






#include "layer1_foundations/foundations.h"
#include "layer2_discreta/discreta.h"
#include "group_actions.h"


using namespace std;


namespace orbiter {
namespace layer3_group_actions {
namespace groups {


conjugacy_class_of_subgroups::conjugacy_class_of_subgroups()
{
	Record_birth();

	Class_data = NULL;
	idx = 0;

	nice_gens = NULL;
	gens = NULL;
	//subgroup_order = 0;
	//class_length = 0;
}



conjugacy_class_of_subgroups::~conjugacy_class_of_subgroups()
{
	Record_death();
	if (gens) {
		FREE_OBJECT(gens);
	}
}

void conjugacy_class_of_subgroups::init(
		interfaces::conjugacy_classes_of_subgroups *Class_data,
		int idx,
		groups::sims *group_G,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "conjugacy_class_of_subgroups::init" << endl;
	}

	//cout << "The conjugacy class " << idx << " / " << nb_classes << " is:" << endl;


	conjugacy_class_of_subgroups::Class_data = Class_data;
	conjugacy_class_of_subgroups::idx = idx;



	//Subgroup_order = NEW_lint(nb_classes);
	//Length = NEW_int(nb_classes);
	//Nb_gens = NEW_int(nb_classes);
	//subgroup_gens = NEW_pint(nb_classes);


	gens = NEW_OBJECT(groups::strong_generators);


	// create strong generators for the cyclic group generated by the idx-th class rep
	// nice_gens will contain the single generator only.
	if (f_v) {
		cout << "conjugacy_class_of_subgroups::init computing H, "
			"before gens->init_from_permutation_representation" << endl;
	}

	gens->init_from_permutation_representation(
			Class_data->A, group_G,
			Class_data->subgroup_gens[idx],
			Class_data->Nb_gens[idx],
			Class_data->Subgroup_order[idx],
			nice_gens,
			verbose_level - 3);


	if (f_v) {
		cout << "conjugacy_class_of_subgroups::init computing H, "
			"after gens->init_from_permutation_representation" << endl;
	}


	if (f_v) {
		cout << "class " << idx << " / " << Class_data->nb_classes
			<< endl;
		cout << "conjugacy_class_of_subgroups::init created "
				"generators for a group" << endl;
		gens->print_generators(cout, verbose_level - 1);
		gens->print_generators_as_permutations();
	}

#if 0
	subgroup_order = gens->group_order_as_lint();
	if (f_v) {
		cout << "conjugacy_class_of_subgroups::report "
				"The group has order " << subgroup_order << endl;
	}
#endif

#if 0
	fp << "\\bigskip" << endl;
	fp << "\\subsection*{Class " << idx << " / "
			<< Class_data->nb_classes << "}" << endl;
	fp << "Order of element = " << Class_data->class_order_of_element[idx]
			<< "\\\\" << endl;
	fp << "Class size = " << Class_data->class_size[idx] << "\\\\" << endl;
	fp << "Centralizer order = " << centralizer_order
			<< "\\\\" << endl;
	fp << "Normalizer order = " << ngo
			<< "\\\\" << endl;

	int *Elt = NULL;


	cout << "latex output element: " << endl;

	if (Class_data->class_order_of_element[idx] > 1) {
		Elt = nice_gens->ith(0);
		fp << "Representing element is" << endl;

		string label;

		label = "c_{" + std::to_string(idx) + "} = ";

		Class_data->A->Group_element->element_print_latex_with_extras(Elt, label, fp);

#if 0

		fp << "$$" << endl;
		element_print_latex(Elt, fp);
		fp << "$$" << endl;
#endif

		fp << "$";
		Class_data->A->Group_element->element_print_for_make_element(Elt, fp);
		fp << "$\\\\" << endl;



	}

	cout << "latex output normalizer: " << endl;


	fp << "The normalizer is generated by:\\\\" << endl;
	N_gens->print_generators_tex(fp);
#endif


#if 0
	if (class_order_of_element[i] > 1) {
		fp << "The fix structure is:\\\\" << endl;
		PA->report_fixed_objects_in_PG_3_tex(
				Elt, fp,
				verbose_level);

		fp << "The orbit structure is:\\\\" << endl;
		PA->report_orbits_in_PG_3_tex(
			Elt, fp,
			verbose_level);
	}
	if (class_order_of_element[i] > 1) {

		PA->report_decomposition_by_single_automorphism(
				Elt, fp,
				verbose_level);
		// PA->
		//action *A; // linear group PGGL(d,q)
		//action *A_on_lines; // linear group PGGL(d,q) acting on lines


	}
#endif

	//FREE_int(class_data->normalizer_generators_perms[i]);

	if (f_v) {
		cout << "conjugacy_class_of_subgroups::init" << endl;
	}

}

std::string conjugacy_class_of_subgroups::stringify_representative_coded(
	int verbose_level)
{
	string s;
	//int *Elt;

	//Elt = nice_gens->ith(0);

	//s = Class_data->A->Group_element->element_stringify_code_for_make_element(Elt);
	return s;
}

void conjugacy_class_of_subgroups::report_single_class(
		std::ofstream &ost, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "conjugacy_class_of_subgroups::report_single_class" << endl;
	}

	if (f_v) {
		cout << "class " << idx << " / " << Class_data->nb_classes << endl;
	}

	ost << "Order of subgroup " << Class_data->Subgroup_order[idx] << "\\\\" << endl;
	ost << "Length of conjugacy class " << Class_data->Length[idx] << "\\\\" << endl;
	ost << "The representative group is generated by:\\\\" << endl;
	gens->print_generators_tex(ost);


	group_theory_global Group_theory_global;
	std::string s;

	if (Class_data->Subgroup_order[idx] < 2500) {
		s = Group_theory_global.order_invariant(
				Class_data->A, gens,
				verbose_level - 3);
	}
	else {
		s = "-1";
	}

	ost << "The order invariant is ";
	ost << "$" << s << "$";
	ost << "\\\\" << endl;

	if (f_v) {
		cout << "conjugacy_class_of_subgroups::report_single_class done" << endl;
	}

}



}}}

